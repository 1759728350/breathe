## 本章总结
三范式    
闭包找候选键  
依赖和决定关系确定  


## 关系模式规范化理论
隶属于逻辑结构设计阶段  
将er图转化为关系模型      
![](img/Pasted%20image%2020230316175809.png)
##### 关系型数据库中的表的种类  
![](img/Pasted%20image%2020221216150426.png)  
只有基表存数据  
  
##### 未规范化问题  
没有进行规范化处理的关系模式存在的问题:  
数据冗余大  
插入异常:多个字段在一个表里,要新插一行因为没有主键无法插入  
删除异常:多个实体放一表一行删一个信息会被全删  
更新日常:全拧在一个表里不仅不方便更新,还会容易漏掉一些行的更新  
![](img/Pasted%20image%2020230316173357.png)
![](img/Pasted%20image%2020230316182615.png)  
##### 函数依赖  
完全依赖于非完全依赖  
  
R(Sno,Sname, Ssex,Cno,Cname, Grade)  
写出关系R的完全函数依赖和部分函数依赖的情况  
完全函数依赖:  
Sno->Sname,Sno->Ssex,Cno->Cname,  
(Sno,Cno)->Grade(两个属性缺一不可,确认后面一个属性)  
<font color=#66CC99 style=" font-weight:bold;">传递依赖也是完全依赖函数</font>  
满足三范式的就是在二范式基础上去掉传递依赖  
  
部分函数依赖:  
(Sno, Cno) ->Sname(<font color=#66CC99 style=" font-weight:bold;">只被括号中的一个属性来确认后面的属性</font>)  
(Sno,Cno) ->Cname  
  
  
传递依赖于非传递依赖  
  
传递函数依赖  
R(A，B，C，D，E)函数依赖关系:  
若满足A一>B,B->C,<font color=#66CC99 style=" font-weight:bold;">且B->A不成立</font>，  
则存在:A通过B传递函数决定了C;  
C通过B传递函数依赖于A ;  
例题  
![](img/Pasted%20image%2020221216165753.png)  
![](img/Pasted%20image%2020221216165917.png)  
### 三范式
1. 第一范式（1NF）：关系模式的每个属性都是原子性的，即不可再分的。

2. 第二范式（2NF）：每个非主属性都完全依赖于候选键（主键）。

3. 第三范式（3NF）：在2NF的基础上，非主属性之间不存在传递依赖，即不能存在A->B，B->C的依赖链。

### 1范式  
<font color=#66CC99 style=" font-weight:bold;">独立列</font>  
![](img/Pasted%20image%2020221216181848.png)  
![](img/Pasted%20image%2020230316183146.png)
### 2范式  
2NF的判定:  
在满足1NF的前提下，每一个<font color=#66CC99 style=" font-weight:bold;">非主属性都完全函数依赖于候选码</font>。  
快速判定2NF的方法:  
若关系模式的<font color=#66CC99 style=" font-weight:bold;">候选码只包含一个</font>(也就是主属性只有个)则该关系模式<font color=#66CC99 style=" font-weight:bold;">肯定满足2NF</font>。  
所以,<font color=#66CC99 style=" font-weight:bold;">看到候选码包含两个时,看其主属性是否只依赖于其中一个,是就排除</font>  
  
例题  
##### 不满足二范式并修复
![](img/Pasted%20image%2020221216183509.png)  
##### 满足二范式
![](img/Pasted%20image%2020221216183554.png)  
  
  
思考  
![](img/Pasted%20image%2020221216231945.png)  
![](img/Pasted%20image%2020221216232331.png)  
连续依赖也属于完全函数依赖  
a->b,b->c c也完全依赖于a,因此非主属性c也完全依赖于候选键a  
因此上题是满足2NF的  
但存在连续函数依赖  
所以满足3NF  
  
### 3范式  
注意:范式都是在前一范式的基础上成立的  
  
3NF的判定:  
若满足2NF的关系模式<font color=#66CC99 style=" font-weight:bold;">不存在</font>非主属性对候选码的<font color=#66CC99 style=" font-weight:bold;">传递函数依赖</font>，则该关系模式满足3NF。  
  
快速判定3NF的方法∶  
若满足2NF的关系模式<font color=#66CC99 style=" font-weight:bold;">只有一个非主属性</font>  
则该关系模式肯定满足3NF。  
  
##### 修改为三范式  
![](img/Pasted%20image%2020221216234644.png)  
  
FD={(运动员编号,比赛项目)->成绩,  
比赛项目->比赛类别,  
比赛类别->比赛主管}//心里想一下,用主人和狗类比一下,别搞倒了  
得到符合三范式的关系模式:  
R1(运动员编号,比赛项目,成绩)  
R2(比赛项目,比赛类别)  
R3(比赛类别,比赛主管)  

### 三范式总结
1、若一个关系满足1NF，则肯定满足(关系中的每一个属性列都是不可分解的最小原子项)  
2、若一个关系满足2NF，则肯定满足(每一个非主属性都完全函数依赖于候选码)  
3、若一个关系满足3NF，则肯定满足(不存在非主属性对候选码的传递函数依赖)  
4、若一个关系不满足1NF，则肯定存在(关系中的属性列不是最小原子项的)问题  
5、若一个关系满足1NF，但不满足2NF，则肯定存在(非主属性对候选码的部分邀数依赖的)问题  
6、若一个关系满足2NF，但不满足3NF，则肯定存在（非主属性对候选码的传递函数依赖的)问题  
7、将不满足1NF的关系优化成1NF的方法(将不满足最小原子项的列中包含的每一个列单独提取出来作为关系中的独立的列)  
8、将满足1NF但不满足2NF的关系优化成2NF的方法(将原关系中完全函数依赖于候选键的非主属性和候选键取出构成独立的关系;将部分依赖于候选键的非主属性和他所部分依赖的主属性取出构成独立的关系模式,照此方法对原关系进行分解)  
参考[不满足二范式并修复](#####不满足二范式并修复)  
9、将满足2NF但不满足3NF的关系优化成3NF的方法(将原关系中的候选键以及候选键能直接决定的非主属性和起到传递性的非主属性取出构成独立的关系;将起到传递性的非主属性和他所能决定的非主属性取出构成独立的关系，照此方法对原关系进行分解)[参考修改为三范式](#####修改为三范式)  
10、无论将关系优化成几范式，要做的事情就是对原关系的(分解) 。  
11、合法的关系具有的特点(列名唯一) ,(列是最小原子项)，(同一列中数据类型相同/列是同质),(列顺序自由)，(行唯一) ，(行顺序自由)



### 关系模式分析  
#### 闭包  
<font color=#F09B59 style=" font-weight:bold;">目的是找候选键</font>
<font color=#F09B59 style=" font-weight:bold;">求当前属性直接或间接推出的依赖集</font>  
用()+来表示  
保底能推出自己  
![](img/Pasted%20image%2020221220210836.png)  
![](img/Pasted%20image%2020230316191508.png)
#### 四类型属性及定理  
L,R,N,LR  
R中属性X是L类属性，则X必为R的任意候选键成员  
X是R类属性，则X不在R的任意候选键中  
R中属性X是N类属性，则X必包含在R的任意候选键中  
  
##### 例1  
![](img/Pasted%20image%2020221221141643.png)  
  
解题思路:  
![](img/Pasted%20image%2020221221213307.png)  
  
##### 例2  
![](img/Pasted%20image%2020221221213407.png)  
L类型属性:A，B ;  
N类型属性:无  
(A，B)的闭包是{ABCD}  
因为(A，B)的闭包包含关系模式R的所有属性列，  
所以(A,B)就是关系模式R的唯一候选码。  
内为存在非主属性D对候选码(A，B)的部分函数依赖，  
所以不满足2NF，是1NF  
  
(2) :  
R1 (A，B，C)候选码:(A，B)  
R2 (A，D)  
候选码:A  
  
##### 例3求候选键  
还要考虑n类型属性  
![](img/Pasted%20image%2020221221215947.png)  
A在左边,但A也在右边,不是L型  
L型的定义是只在左边的属性  
![](img/Pasted%20image%2020221221220329.png)  
![](img/Pasted%20image%2020230316191901.png)
#### 公理  
了解一下,简单  
![](img/Pasted%20image%2020221221213811.png)  
  
例题  
![](img/Pasted%20image%2020221221221107.png)  
#### 函数依赖关系和联系的关联  
若X和Y是1:1关系，则存在函数依赖:X->Y且Y->X  
若X和Y是m:1关系，则存在函数依赖:X->Y  
若X和Y是m:n关系，则X和Y不存在函数依赖关系  
<font color=#F09B59 style=" font-weight:bold;">箭头推出就是决定,依赖于是决定的反义词</font>
![](img/Pasted%20image%2020230316190100.png)
##### 依赖于与决定
![](img/Pasted%20image%2020221221221139.png)  
B依赖于A -- A指向B--N:1

<font color=#F09B59 style=" font-weight:bold;">把"A决定B"理解为A指向B,箭头指向的一方为一,开始为多</font>
<font color=#66CC99 style=" font-weight:bold;">"依赖于"就是决定的反义词</font>
![](img/Pasted%20image%2020230316185742.png)
上图既可以说学生决定老师  
也可以说老师依赖于学生



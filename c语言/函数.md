函数名就是个地址  

##### 函数的指针  
```c
//pp要加括号,不然就是个*pp的函数了
int (*pp)(const char *s,...);

pp = printf;
pp("sadasdsd");//用pp接收printf函数
```
接收函数的指针的声明要加上参数类型和返回类型
```c
pp = printf;

pp("%p\n",printf);//0000000000402AA0
//pp接收的地址就是函数printf函数的地址
printf("%p\n",pp);//0000000000402AA0
```

##### 存函数地址的数组
创建一个数组去有序的存多个函数地址  
```c
int (*arr[5])(int,int);
p[0] = function1;
p[1] = function2;
p[day](10,20);
```
详细例子
```c
int fun1(int x,int y){
    int r = x+y;
    return r;
}
int fun2(int x,int y){
    int r = x-y;
    return r;
}
int fun3(int x,int y){
    int r = x*y;
    return r;
}
int main() {
    int (*pp[3])(int,int);
    pp[0] = fun1;
    pp[1] = fun2;
    pp[2] = fun3;

    int x = pp[2](10,10);
    printf("%d",x);
    return 0;
}
```

### 参数传递
函数默认是地址传递

#### 地址传递
```c
void swap(int *a,int *b){
    int c;
    c = *a;
    *a = *b;
    *b = c;
}
int main() {
    int a = 3;
    int b = 5;
    swap(&a,&b);
    printf("a=%d,b=%d",a,b);
    return 0;
}
```
##### 按值传递和地址传递区别
地址当做参数才能修改地址对应空间的内容  
值传递只是传递一份拷贝  
这也意味着  
当一个函数的参数是需要你传地址时  
这就代表你需要这个函数去修改对应地址空间的内容   
比如  
```c
scanf("%d",&a);//把a的地址给scanf去修改a地址空间的内容
//内容来自于你键盘输入
scanf("%d",a);//键盘输入的值覆盖不了a的值,因为是按值传递
```

#### 结构体作为参数传递
结构体这种连续的大块内存建议用地址传递  
按值传递会拷贝一份结构体过去  
下面这个代码就能看出  
```c
struct Stu{
    int age;
    char name[10];
}stu = {22,"lyh"};
//这个stu实例是全局变量,一开始就分配了空间

//typedef struct Stu Stu;
void kk(struct Stu stu){
    
    printf("初始地址%d\n",&stu);//鍒濆鍦板潃6422032
    printf("%d\n",&(stu.age));//6422032
};
void kk2(struct Stu *stu){
    
    printf("初始地址%d\n",stu);//鍒濆鍦板潃4206608
    printf("%d",&(stu->age));//4206608
}

int main() {
    //不用创建stu对象,因为已经是全局变量了,分配了内存空间
    kk(stu);//按值传递又分配了一块以6422032为初始的地址的空间
    kk2(&stu);

    return 0;
}
```
#### 数组传递
sizeof在子函数里求不出数组的长度  
因此需要主函数将数组长作为参数传给他  
```c
//实参
int ab[10];
fun(ab)

//形参
void fun(int* p)
```
具体
```c
int fun1(int *p,int len){

    for (int i = 0; i < len; i++) {
        printf("%d\n",p[i]);
    }
}
int main() {
    int s[10] = {1,2,3,4};
    int len = sizeof(s)/sizeof(int);
    fun1(s,len);

    return 0;
}
```
#### 只读连续空间传递
用形参用const修饰,让函数调用者知道这个是不能改的只读连续空间
```c
int fun1(const char* p){
    p[0] = 1;
}
int main() {
    //const char *s = "abcdef";
    fun1("123456");
    return 0;
}
```
详细看[字符数组两种定义方式](数组###字符数组)
```c
//strcpy就是不能修改元副本,但是拷贝的备份dest可以修改
char *strcpy(char *dest,const char *src);
```

#### 连续字符空间传递
```c
int strlen1(const char* p){
    int i = 0;
    if (p == NULL){
        return 1;
    }//因为最后一位是0结尾,因此传递参数时不需要长度
    while (p[i] != 0){//也可以写成while(p[0])
        printf("%c\n",p[i]);
        i++;
    }
}
int main() {
    strlen1("123456");
    return 0;
}
```



#### 连续非字符空间传递
非字符的连续空间一般类型有  
非字符连续空间不用char类型  
```c
int *p;
unsigned char *p;
short *p;
struct abc *p;
//这些类型都可以用void *来作为形参接收
//所以看到非字符空间,就是采集的数据
//void没有长度,参数还要算sizeof传长度
```

memcpy例子
```c
//拷贝内存函数
//可以把任意类型的数据拷贝到指定位置dest上
//n表示长度
void *memcpy(void *dest,const void *src,size_t n);
```
使用void类型作为形参时最好不要接收char类型
```c
//char类型用来接收数据的缺点是什么
//char存字符数组,结尾是0
//所以下面你用%s打印是不行的,因为采集的数据可能有0
//打印到一半就中断了
char buf[100];
//char最高位是表示正负的
recv(buf);//假设里面形参是void *
printf("%s",buf);
```
##### 用void的好处
上面的这四种类型都可以直接取地址然后传过去  
[类型转换](数据类型####强制类型转换)


### 返回类型
对于连续空间的返回,空间本身要有意义  
<font color=#66CC99 style=" font-weight:bold;">返回的是局部变量的值,是可以返回的,但如果是局部变量的指针的话,因为该函数执行完毕,已经销毁空间</font>  
<font color=#F09B59 style=" font-weight:bold;">你用该指针再获取到的原先的连续空间已经没有意义,因为已经被销毁</font>  
```c
#include <stdio.h>
char *fun1();
char *fun2();
void main(){
    char *p;
    p = fun1();
    printf("p1 is %s\n",p);
    p = fun2();
    printf("p2 is %s",p);
}
char *fun1(){
    char str[] = "abcd1";   //p1 is (null)
    return str;
}
char *fun2(){
    return "abcd2";    //p2 is abcd2
}
```
详细看[字符数组两种定义方式](数组###字符数组)

#### 如何解决返回局部变量指针
连续空间的局部变量的指针传出去方法有三种
##### 1.static改变存储位置
```c
void main(){
    char *p;
    p = fun1();
    printf("p1 is %s\n",p);

}
char *fun1(void){
    //加static后str这个连续空间就不会因为函数执行完毕就销毁
    //返回的指针就有意义了
    static char str[] = "abcd";
    return str;
}
```

##### 2.堆区分配内存
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>//malloc
char *fun1();

int main(){
    char *p;
    p = fun1();
    printf("p1 is %s\n",p);
    free(p);
    return 0;
}
char *fun1(void){
    char *p = (char *)malloc(100);
    strcpy(p,"hello wo");
    return p;
}
```
1/3=0整数默认用int算,直接截取整数部分  
可以改成1.0/3  
c语言中就switch分支和取模是只能用整数的  

double用%lf,float用%f   

printf("%m.nf",a)  
m是填充位,n是小数点后的精度,如果a是2.555,n是2  
则输出2.56,会进行四舍五入  
输出的长度大于m,就原样输出,点号也算  
小于m,就是左侧填充  

scanf("%mf",&a)  
scanf不可以指定精度  
m宽度小数点也算一位,直接截取掉超过m的输入部分  
且不会四舍五入,只有printf的精度才会涉及到四舍五入  

c语言数组  
int a\[] = {1,2,3}  
int a\[3] = {}  
数组的长度在初始化赋值后可以不规定长度  

数组的长度只能是确认的数,不能是变量  
define和常数可以  
int n = 3  
int a\[n] = {},这是典型的错误,长度不能是变量  

c语言数组地址的表示方式  
int a\[3] = {}中a是地址,是该数组的初始地址  
可以通过步进来获取所有元素的地址  
第一个元素地址:a  
第二个元素地址:a+1,第三个a+2.......  
不能用a++来表示,为什么呢?因为这个加一操作实际上是语法糖  
int的宽度不止1,因此对于数组初始地址加1是便捷获取地址的语法糖  

数组的地址和字符串(c语言中一段字符串代表地址)都是常量,不能被赋值更改  

取地址符&  
在拥有一个变量名的前提下,获取该变量地址  
取指针指向的对应内存地址的值\*  
\*p 取p指针指向的内存地址的值


![](img/Pasted%20image%2020230201234246.png)

字符串数组以\\0结尾,也占一个位置  
![](img/Pasted%20image%2020230202014515.png)

sizeof:计算变量所占内存大小,包含\\0,看数据类型就知道了,char就占一位  
strlen:\\0之前的字符个数  
"hello world",sizeof算出来11个字节,strlen算出来10个字符长度  
![](img/Pasted%20image%2020230202162237.png)


字符串循环方式  
![](img/Pasted%20image%2020230202015357.png)
字符串数组可以不用大括号
![](img/Pasted%20image%2020230202022025.png)


strcat(字符串1首地址,字符串2首地址)
字符串2直接拼接到1上
```c
    char s1[10] = "123";
    char s2[] = "456";

    printf("%s\n",strcat(s1,s2));
    puts(s1);
    //输出
    //123456
    //123456
```
![](img/Pasted%20image%2020230202163937.png) 
理论上s1数组要足够长才行,但实际实验中s1会扩容

strcpy函数
strcpy(地址1,地址2)
字符串2一个一个覆盖掉字符串1
![](img/Pasted%20image%2020230202173706.png)
输出s1时就是s2的abc,因为输出字符串到\\0就会停止

c语言中字符串就是常量,常量不能被更改